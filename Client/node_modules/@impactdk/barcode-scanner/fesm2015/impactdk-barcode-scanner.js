import { __awaiter } from 'tslib';
import rawr from 'rawr';
import transport from 'rawr/transports/worker';

class Scanner {
    constructor(videoElement, decoder, cb) {
        this.videoElement = videoElement;
        this.decoder = decoder;
        this.cb = cb;
        this.constraints = {
            video: {
                facingMode: "environment"
            },
            audio: false
        };
        this.running = false;
        this.resolve = () => null;
        this.reject = () => null;
        this.decodeCanvas = document.createElement("canvas");
        this.onLoadedData = this.onLoadedData.bind(this);
        this.getOnFrameHandler = this.getOnFrameHandler.bind(this);
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.running = true;
            this.videoElement = this.videoElement;
            this.videoElement.addEventListener("loadeddata", this.onLoadedData);
            // Ensure correct attributes
            this.videoElement.setAttribute("autoplay", "");
            this.videoElement.setAttribute("muted", "");
            this.videoElement.setAttribute("playsinline", "");
            const stream = yield navigator.mediaDevices.getUserMedia(this.constraints);
            this.videoElement.srcObject = stream;
            return new Promise((res, rej) => {
                this.resolve = res;
                this.reject = rej;
            });
        });
    }
    stop() {
        if (!this.videoElement || !this.videoElement.srcObject) {
            return;
        }
        this.videoElement.removeEventListener("loadeddata", this.onLoadedData);
        const ms = this.videoElement.srcObject;
        ms.getTracks().forEach(t => t.stop());
        this.videoElement.srcObject = null;
        this.running = false;
    }
    onLoadedData() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.decodeCanvas || !this.videoElement) {
                this.reject();
                return;
            }
            this.decodeCanvas.height = this.videoElement.videoHeight;
            this.decodeCanvas.width = this.videoElement.videoWidth;
            requestAnimationFrame(this.getOnFrameHandler());
        });
    }
    getOnFrameHandler() {
        if (!this.decodeCanvas) {
            return () => null;
        }
        this.resolve();
        const decodeCtx = this.decodeCanvas.getContext("2d");
        const onFrame = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.decodeCanvas || !this.videoElement) {
                return;
            }
            decodeCtx.drawImage(this.videoElement, 0, 0, this.videoElement.videoWidth, this.videoElement.videoHeight);
            let barcode = null;
            try {
                barcode = yield this.decoder.decode(decodeCtx);
                if (barcode) {
                    this.cb(barcode);
                }
            }
            catch (err) {
                console.log({ decodeError: err.message });
            }
            if (this.running) {
                requestAnimationFrame(onFrame);
            }
        });
        return onFrame;
    }
}

const workerFileName = "wasm-worker.js";
function sanitizeDirString(s) {
    return s.replace(/\/$/, "");
}
class WasmDecoder {
    constructor(installationDir = "") {
        const workerFilePath = `${installationDir}/${workerFileName}`;
        this.worker = new Worker(workerFilePath);
        this.wasmDecoder = rawr({ transport: transport(this.worker) });
    }
    static getInstance(installationDir = "") {
        if (!WasmDecoder.instance) {
            const sanitized = sanitizeDirString(installationDir);
            WasmDecoder.instance = new WasmDecoder(sanitized);
        }
        return WasmDecoder.instance;
    }
    static removeInstance() {
        WasmDecoder.instance.dispose();
        WasmDecoder.instance = null;
    }
    decode(context) {
        const canvas = context.canvas;
        const width = canvas.width;
        const height = canvas.height;
        const imageData = context.getImageData(0, 0, width, height);
        return this.wasmDecoder.methods.detectUrl(width, height, imageData);
    }
    dispose() {
        this.wasmDecoder = null;
        this.worker.terminate();
    }
}

export { Scanner, WasmDecoder };
//# sourceMappingURL=impactdk-barcode-scanner.js.map
