{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\n\nconst transports = require('./transports');\n\nfunction rawr({\n  transport,\n  timeout = 0,\n  handlers = {},\n  methods\n}) {\n  let callId = 0; // eslint-disable-next-line no-param-reassign\n\n  methods = methods || handlers; // backwards compat\n\n  const pendingCalls = {};\n  const methodHandlers = {};\n  const notificationEvents = new EventEmitter();\n  notificationEvents.on = notificationEvents.on.bind(notificationEvents);\n  transport.on('rpc', msg => {\n    if (msg.id) {\n      // handle an RPC request\n      if (msg.params && methodHandlers[msg.method]) {\n        methodHandlers[msg.method](msg);\n        return;\n      } // handle an RPC result\n\n\n      const promise = pendingCalls[msg.id];\n\n      if (promise) {\n        if (promise.timeoutId) {\n          clearTimeout(promise.timeoutId);\n        }\n\n        delete pendingCalls[msg.id];\n\n        if (msg.error) {\n          promise.reject(msg.error);\n        }\n\n        return promise.resolve(msg.result);\n      }\n\n      return;\n    } // handle a notification\n\n\n    msg.params.unshift(msg.method);\n    notificationEvents.emit(...msg.params);\n  });\n\n  function addHandler(methodName, handler) {\n    methodHandlers[methodName] = msg => {\n      Promise.resolve().then(() => {\n        return handler.apply(this, msg.params);\n      }).then(result => {\n        transport.send({\n          id: msg.id,\n          result\n        });\n      }).catch(error => {\n        const serializedError = {\n          message: error.message\n        };\n\n        if (error.code) {\n          serializedError.code = error.code;\n        }\n\n        transport.send({\n          id: msg.id,\n          error: serializedError\n        });\n      });\n    };\n  }\n\n  Object.keys(methods).forEach(m => {\n    addHandler(m, methods[m]);\n  });\n  const methodsProxy = new Proxy({}, {\n    get: (target, name) => {\n      return (...args) => {\n        const id = ++callId;\n        const msg = {\n          jsonrpc: '2.0',\n          method: name,\n          params: args,\n          id\n        };\n        let timeoutId;\n\n        if (timeout) {\n          timeoutId = setTimeout(() => {\n            if (pendingCalls[id]) {\n              const err = new Error('RPC timeout');\n              err.code = 504;\n              pendingCalls[id].reject(err);\n              delete pendingCalls[id];\n            }\n          }, timeout);\n        }\n\n        const response = new Promise((resolve, reject) => {\n          pendingCalls[id] = {\n            resolve,\n            reject,\n            timeoutId\n          };\n        });\n        transport.send(msg);\n        return response;\n      };\n    }\n  });\n  const notifiers = new Proxy({}, {\n    get: (target, name) => {\n      return (...args) => {\n        const msg = {\n          jsonrpc: '2.0',\n          method: name,\n          params: args\n        };\n        transport.send(msg);\n      };\n    }\n  });\n  const notifications = new Proxy({}, {\n    get: (target, name) => {\n      return callback => {\n        notificationEvents.on(name.substring(2), (...args) => {\n          return callback.apply(callback, args);\n        });\n      };\n    }\n  });\n  return {\n    methods: methodsProxy,\n    addHandler,\n    notifications,\n    notifiers\n  };\n}\n\nrawr.transports = transports;\nmodule.exports = rawr;","map":{"version":3,"sources":["C:/Users/aarib/Desktop/REACT_BootCamp/whatsCooking/node_modules/rawr/index.js"],"names":["EventEmitter","require","transports","rawr","transport","timeout","handlers","methods","callId","pendingCalls","methodHandlers","notificationEvents","on","bind","msg","id","params","method","promise","timeoutId","clearTimeout","error","reject","resolve","result","unshift","emit","addHandler","methodName","handler","Promise","then","apply","send","catch","serializedError","message","code","Object","keys","forEach","m","methodsProxy","Proxy","get","target","name","args","jsonrpc","setTimeout","err","Error","response","notifiers","notifications","callback","substring","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAmBC,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AAEA,SAASE,IAAT,CAAc;AAAEC,EAAAA,SAAF;AAAaC,EAAAA,OAAO,GAAG,CAAvB;AAA0BC,EAAAA,QAAQ,GAAG,EAArC;AAAyCC,EAAAA;AAAzC,CAAd,EAAkE;AAChE,MAAIC,MAAM,GAAG,CAAb,CADgE,CAEhE;;AACAD,EAAAA,OAAO,GAAGA,OAAO,IAAID,QAArB,CAHgE,CAGjC;;AAC/B,QAAMG,YAAY,GAAG,EAArB;AACA,QAAMC,cAAc,GAAG,EAAvB;AACA,QAAMC,kBAAkB,GAAG,IAAIX,YAAJ,EAA3B;AACAW,EAAAA,kBAAkB,CAACC,EAAnB,GAAwBD,kBAAkB,CAACC,EAAnB,CAAsBC,IAAtB,CAA2BF,kBAA3B,CAAxB;AAEAP,EAAAA,SAAS,CAACQ,EAAV,CAAa,KAAb,EAAqBE,GAAD,IAAS;AAC3B,QAAIA,GAAG,CAACC,EAAR,EAAY;AACV;AACA,UAAID,GAAG,CAACE,MAAJ,IAAcN,cAAc,CAACI,GAAG,CAACG,MAAL,CAAhC,EAA8C;AAC5CP,QAAAA,cAAc,CAACI,GAAG,CAACG,MAAL,CAAd,CAA2BH,GAA3B;AACA;AACD,OALS,CAMV;;;AACA,YAAMI,OAAO,GAAGT,YAAY,CAACK,GAAG,CAACC,EAAL,CAA5B;;AACA,UAAIG,OAAJ,EAAa;AACX,YAAIA,OAAO,CAACC,SAAZ,EAAuB;AACrBC,UAAAA,YAAY,CAACF,OAAO,CAACC,SAAT,CAAZ;AACD;;AACD,eAAOV,YAAY,CAACK,GAAG,CAACC,EAAL,CAAnB;;AACA,YAAID,GAAG,CAACO,KAAR,EAAe;AACbH,UAAAA,OAAO,CAACI,MAAR,CAAeR,GAAG,CAACO,KAAnB;AACD;;AACD,eAAOH,OAAO,CAACK,OAAR,CAAgBT,GAAG,CAACU,MAApB,CAAP;AACD;;AACD;AACD,KApB0B,CAqB3B;;;AACAV,IAAAA,GAAG,CAACE,MAAJ,CAAWS,OAAX,CAAmBX,GAAG,CAACG,MAAvB;AACAN,IAAAA,kBAAkB,CAACe,IAAnB,CAAwB,GAAGZ,GAAG,CAACE,MAA/B;AACD,GAxBD;;AA0BA,WAASW,UAAT,CAAoBC,UAApB,EAAgCC,OAAhC,EAAyC;AACvCnB,IAAAA,cAAc,CAACkB,UAAD,CAAd,GAA8Bd,GAAD,IAAS;AACpCgB,MAAAA,OAAO,CAACP,OAAR,GACGQ,IADH,CACQ,MAAM;AACV,eAAOF,OAAO,CAACG,KAAR,CAAc,IAAd,EAAoBlB,GAAG,CAACE,MAAxB,CAAP;AACD,OAHH,EAIGe,IAJH,CAISP,MAAD,IAAY;AAChBpB,QAAAA,SAAS,CAAC6B,IAAV,CAAe;AACblB,UAAAA,EAAE,EAAED,GAAG,CAACC,EADK;AAEbS,UAAAA;AAFa,SAAf;AAID,OATH,EAUGU,KAVH,CAUUb,KAAD,IAAW;AAChB,cAAMc,eAAe,GAAG;AAAEC,UAAAA,OAAO,EAAEf,KAAK,CAACe;AAAjB,SAAxB;;AACA,YAAIf,KAAK,CAACgB,IAAV,EAAgB;AACdF,UAAAA,eAAe,CAACE,IAAhB,GAAuBhB,KAAK,CAACgB,IAA7B;AACD;;AACDjC,QAAAA,SAAS,CAAC6B,IAAV,CAAe;AACblB,UAAAA,EAAE,EAAED,GAAG,CAACC,EADK;AAEbM,UAAAA,KAAK,EAAEc;AAFM,SAAf;AAID,OAnBH;AAoBD,KArBD;AAsBD;;AAEDG,EAAAA,MAAM,CAACC,IAAP,CAAYhC,OAAZ,EAAqBiC,OAArB,CAA8BC,CAAD,IAAO;AAClCd,IAAAA,UAAU,CAACc,CAAD,EAAIlC,OAAO,CAACkC,CAAD,CAAX,CAAV;AACD,GAFD;AAIA,QAAMC,YAAY,GAAG,IAAIC,KAAJ,CAAU,EAAV,EAAc;AACjCC,IAAAA,GAAG,EAAE,CAACC,MAAD,EAASC,IAAT,KAAkB;AACrB,aAAO,CAAC,GAAGC,IAAJ,KAAa;AAClB,cAAMhC,EAAE,GAAG,EAAEP,MAAb;AACA,cAAMM,GAAG,GAAG;AACVkC,UAAAA,OAAO,EAAE,KADC;AAEV/B,UAAAA,MAAM,EAAE6B,IAFE;AAGV9B,UAAAA,MAAM,EAAE+B,IAHE;AAIVhC,UAAAA;AAJU,SAAZ;AAOA,YAAII,SAAJ;;AACA,YAAId,OAAJ,EAAa;AACXc,UAAAA,SAAS,GAAG8B,UAAU,CAAC,MAAM;AAC3B,gBAAIxC,YAAY,CAACM,EAAD,CAAhB,EAAsB;AACpB,oBAAMmC,GAAG,GAAG,IAAIC,KAAJ,CAAU,aAAV,CAAZ;AACAD,cAAAA,GAAG,CAACb,IAAJ,GAAW,GAAX;AACA5B,cAAAA,YAAY,CAACM,EAAD,CAAZ,CAAiBO,MAAjB,CAAwB4B,GAAxB;AACA,qBAAOzC,YAAY,CAACM,EAAD,CAAnB;AACD;AACF,WAPqB,EAOnBV,OAPmB,CAAtB;AAQD;;AAED,cAAM+C,QAAQ,GAAG,IAAItB,OAAJ,CAAY,CAACP,OAAD,EAAUD,MAAV,KAAqB;AAChDb,UAAAA,YAAY,CAACM,EAAD,CAAZ,GAAmB;AAAEQ,YAAAA,OAAF;AAAWD,YAAAA,MAAX;AAAmBH,YAAAA;AAAnB,WAAnB;AACD,SAFgB,CAAjB;AAIAf,QAAAA,SAAS,CAAC6B,IAAV,CAAenB,GAAf;AAEA,eAAOsC,QAAP;AACD,OA5BD;AA6BD;AA/BgC,GAAd,CAArB;AAkCA,QAAMC,SAAS,GAAG,IAAIV,KAAJ,CAAU,EAAV,EAAc;AAC9BC,IAAAA,GAAG,EAAE,CAACC,MAAD,EAASC,IAAT,KAAkB;AACrB,aAAO,CAAC,GAAGC,IAAJ,KAAa;AAClB,cAAMjC,GAAG,GAAG;AACVkC,UAAAA,OAAO,EAAE,KADC;AAEV/B,UAAAA,MAAM,EAAE6B,IAFE;AAGV9B,UAAAA,MAAM,EAAE+B;AAHE,SAAZ;AAKA3C,QAAAA,SAAS,CAAC6B,IAAV,CAAenB,GAAf;AACD,OAPD;AAQD;AAV6B,GAAd,CAAlB;AAaA,QAAMwC,aAAa,GAAG,IAAIX,KAAJ,CAAU,EAAV,EAAc;AAClCC,IAAAA,GAAG,EAAE,CAACC,MAAD,EAASC,IAAT,KAAkB;AACrB,aAAQS,QAAD,IAAc;AACnB5C,QAAAA,kBAAkB,CAACC,EAAnB,CAAsBkC,IAAI,CAACU,SAAL,CAAe,CAAf,CAAtB,EAAyC,CAAC,GAAGT,IAAJ,KAAa;AACpD,iBAAOQ,QAAQ,CAACvB,KAAT,CAAeuB,QAAf,EAAyBR,IAAzB,CAAP;AACD,SAFD;AAGD,OAJD;AAKD;AAPiC,GAAd,CAAtB;AAUA,SAAO;AACLxC,IAAAA,OAAO,EAAEmC,YADJ;AAELf,IAAAA,UAFK;AAGL2B,IAAAA,aAHK;AAILD,IAAAA;AAJK,GAAP;AAMD;;AAEDlD,IAAI,CAACD,UAAL,GAAkBA,UAAlB;AAEAuD,MAAM,CAACC,OAAP,GAAiBvD,IAAjB","sourcesContent":["const { EventEmitter } = require('events');\nconst transports = require('./transports');\n\nfunction rawr({ transport, timeout = 0, handlers = {}, methods }) {\n  let callId = 0;\n  // eslint-disable-next-line no-param-reassign\n  methods = methods || handlers; // backwards compat\n  const pendingCalls = {};\n  const methodHandlers = {};\n  const notificationEvents = new EventEmitter();\n  notificationEvents.on = notificationEvents.on.bind(notificationEvents);\n\n  transport.on('rpc', (msg) => {\n    if (msg.id) {\n      // handle an RPC request\n      if (msg.params && methodHandlers[msg.method]) {\n        methodHandlers[msg.method](msg);\n        return;\n      }\n      // handle an RPC result\n      const promise = pendingCalls[msg.id];\n      if (promise) {\n        if (promise.timeoutId) {\n          clearTimeout(promise.timeoutId);\n        }\n        delete pendingCalls[msg.id];\n        if (msg.error) {\n          promise.reject(msg.error);\n        }\n        return promise.resolve(msg.result);\n      }\n      return;\n    }\n    // handle a notification\n    msg.params.unshift(msg.method);\n    notificationEvents.emit(...msg.params);\n  });\n\n  function addHandler(methodName, handler) {\n    methodHandlers[methodName] = (msg) => {\n      Promise.resolve()\n        .then(() => {\n          return handler.apply(this, msg.params);\n        })\n        .then((result) => {\n          transport.send({\n            id: msg.id,\n            result\n          });\n        })\n        .catch((error) => {\n          const serializedError = { message: error.message };\n          if (error.code) {\n            serializedError.code = error.code;\n          }\n          transport.send({\n            id: msg.id,\n            error: serializedError\n          });\n        });\n    };\n  }\n\n  Object.keys(methods).forEach((m) => {\n    addHandler(m, methods[m]);\n  });\n\n  const methodsProxy = new Proxy({}, {\n    get: (target, name) => {\n      return (...args) => {\n        const id = ++callId;\n        const msg = {\n          jsonrpc: '2.0',\n          method: name,\n          params: args,\n          id\n        };\n\n        let timeoutId;\n        if (timeout) {\n          timeoutId = setTimeout(() => {\n            if (pendingCalls[id]) {\n              const err = new Error('RPC timeout');\n              err.code = 504;\n              pendingCalls[id].reject(err);\n              delete pendingCalls[id];\n            }\n          }, timeout);\n        }\n\n        const response = new Promise((resolve, reject) => {\n          pendingCalls[id] = { resolve, reject, timeoutId };\n        });\n\n        transport.send(msg);\n\n        return response;\n      };\n    }\n  });\n\n  const notifiers = new Proxy({}, {\n    get: (target, name) => {\n      return (...args) => {\n        const msg = {\n          jsonrpc: '2.0',\n          method: name,\n          params: args\n        };\n        transport.send(msg);\n      };\n    }\n  });\n\n  const notifications = new Proxy({}, {\n    get: (target, name) => {\n      return (callback) => {\n        notificationEvents.on(name.substring(2), (...args) => {\n          return callback.apply(callback, args);\n        });\n      };\n    }\n  });\n\n  return {\n    methods: methodsProxy,\n    addHandler,\n    notifications,\n    notifiers\n  };\n}\n\nrawr.transports = transports;\n\nmodule.exports = rawr;\n"]},"metadata":{},"sourceType":"script"}